\capitulo{3}{Conceptos teóricos}

En este capítulo se describe cómo se establece la base del proyecto, demostrando que la propuesta no solo resuelve un problema práctico, sino que también está fundamentada en principios bien establecidos.

\section{Sistemas de Gestión de Reservas}

El sistema de gestión de reservas es una herramienta que facilita la asignación de recursos, como salas de reuniones. Aunque éste fue el punto de partida, la aplicación ha sido diseñada para ser adaptable; se puede utilizar en diferentes sectores, como restaurantes, servicios y para la gestión de citas.

En el contexto de este TFG, para que la experiencia de reserva fuera lo más intuitiva posible, se ha introducido el concepto de \textbf{``slots''} o intervalos de tiempo. De modo que se han diferenciado los espacios de reserva en dos tipos para que el usuario pueda elegir el que mejor se adapte a su necesidad:
\begin{itemize}
\tightlist
   \item \textbf{Duración variable}: Es la opción que ofrece flexibilidad, permitiendo al usuario elegir la hora de inicio y fin de su reserva.
   \item \textbf{Duración fija}: Para estos casos, la aplicación muestra una serie de horarios preestablecidos (los ``slots''), facilitando al usuario la selección de un intervalo de tiempo ya definido, agilizando con ello el proceso.
\end{itemize}

Otro concepto a tener en cuenta es el de aforo. Los valores de aforo no hacen referencia a la capacidad de una sala, que para eso ya está el atributo de capacidad, sino a la cantidad de reservas que pueden concurrir al mismo tiempo. El aforo está orientado a los establecimiento que se rigen por ``slots'' de modo que si un establecimiento tiene de aforo 2, significa que permite que se realicen 2 reservas para el mismo periodo de tiempo.

\section{Arquitectura de Aplicaciones Web}

\subsubsection{Patrones de Arquitectura}
Para el desarrollo de la aplicación se ha aplicado el conocido patrón Modelo-Vista-Controlador (MVC)~\cite{modelo-vista-controrlador}, consiguiendo una solución estructurada y desacoplada, y para ello se ha aprovechado las características del ecosistema Spring obteniendo una aplicación web sólida y fácil de mantener, separando mediante capas la lógica de negocio, la de presentación y la de control de la aplicación:
\begin{itemize}
\tightlist
   \item \textbf{Modelo}: Gestiona los datos y la lógica de negocio. Implementado en Spring Boot con acceso a la base de datos MySQL.
   \item \textbf{Vista}: Representa la interfaz de usuario, creada con Thymeleaf.
   \item \textbf{Controlador}: Maneja las interacciones del usuario y actualiza el modelo o la vista según corresponda.
\end{itemize}
Esta arquitectura modular facilita la escalabilidad, el mantenimiento y la reutilización de código.
\imagen{modelo-mvc}{Patrón modelo MVC.}{1}

\newpage

\subsubsection{Arquitectura Cliente-Servidor}
La arquitectura de la aplicación web sigue un modelo cliente-servidor~\cite{client-server-model}, donde:
\begin{itemize}
\tightlist
   \item \textbf{Cliente o \emph{frontend}}: Representado por el navegador web del usuario, que interactúa con la aplicación a través de una interfaz construida con Thymeleaf.
   \item \textbf{Servidor o \emph{backend}}: Implementado con Java y Spring Boot, que procesa las solicitudes del cliente, accede a la base de datos MySQL y devuelve las respuestas correspondientes.
\end{itemize}
\imagen{cliente-servidor}{Arquitectura Cliente-Servidor.}{1}

\section{Patrones de diseño}\label{patron-de-diseño}

El sistema ha sido diseñado siguiendo principios de arquitectura en capas, separación de responsabilidades y buenas prácticas de desarrollo. A continuación, se describen algunos de los patrones utilizados.

\subsection{Patrón Modelo-Vista-Controlador (MVC)}\label{patron-modelo-vista-controlador}
Para el desarrollo de la aplicación web de gestión de reservas con Spring Boot, se siguió el patrón MVC por su separación clara de responsabilidades que facilita el mantenimiento y escalabilidad del código al dividir la lógica de negocio (Modelo), la presentación (Vista) y el control de flujo (Controlador). Su integración nativa con Spring Boot mediante las anotaciones que ofrece el \emph{framework} simplifica significativamente el desarrollo. Además, ofrece flexibilidad para cambios futuros como modificar la interfaz de usuario sin afectar la lógica de negocio, o modificar la lógica de negocio sin afectar a la capa visual o al modelo de datos.

\subsection{Arquitectura por Capas}\label{arquitectura-por-capas}
De alguna forma, o bien como consecuencia o bien como complementación al punto anterior, el patrón MVC favorece la construcción de los diferentes elementos separándose en diferentes capas, donde cada capa (presentación, lógica de negocio, acceso a datos) se alinea naturalmente con los componentes MVC, creando una estructura coherente y bien organizada. Esta estructura proporciona alta cohesión y bajo acoplamiento, permitiendo que los cambios en una capa (como modificar la base de datos) no afecten a las demás, mientras que MVC organiza la interacción usuario-sistema dentro de cada capa. Además, esta separación facilita la implementación de principios SOLID~\cite{solid} posibilitando el \emph{testing} independiente de cada capa, donde se puede probar la lógica de negocio sin depender de la interfaz de usuario o de la base de datos. Esta combinación entre arquitectura por capas y MVC es una buena práctica que conduce a un diseño maduro y profesional que cumple con los estándares para el desarrollo de aplicaciones.

\subsection{Patrón Repository}\label{patron-repository}
Al disponer Spring Boot de una integración nativa con Spring Data JPA, se permite la creación de repositorios automáticamente mediante interfaces, reduciendo significativamente el código. Este patrón abstrae la lógica de acceso a los datos de la capa de negocio, permitiendo cambiar la implementación de la capa de persistencia sin afectar el resto de la aplicación y facilitando el \emph{testing} mediante \emph{mocks}. Además, Spring Boot proporciona funcionalidades avanzadas como \emph{query methods} automáticos y paginación. El uso de este patrón garantiza el cumplimiento del principio de inversión de dependencias, creando una arquitectura limpia y mantenible.
\imagen{patron-repository2}{Patrón Repository.}{1}

\subsection{Patrón Service Layer}\label{patron-service-layer}
Gracias a la utilización del patrón de diseño MVC comentado anteriormente, la implementación conduce casi de forma intuitiva o directa al uso del patrón \emph{service layer} que actúa como intermediario entre los \emph{Controllers} y los \emph{Repositories}, encapsulando toda la lógica de negocio y las reglas de validación en una capa dedicada que mantiene los controladores enfocados únicamente al manejo de peticiones HTTP. Su integración con Spring Boot mediante \emph{@Service} facilita la inyección de dependencias y la gestión transaccional con \emph{@Transactional}, permitiendo la reutilización de la lógica de negocio desde diferentes controladores o incluso APIs REST y servicios web. Este patrón refuerza la separación de responsabilidades del MVC, donde el Controller delega las operaciones complejas en el \emph{Service}, que a su vez utiliza los \emph{Repositories} para la persistencia, creando una arquitectura limpia, testeable y que cumple con los principios de buenas prácticas del diseño de software.

\subsection{Patrón Data Transfer Object (DTO)}\label{patron-data-transfer-object}
Con el uso del patrón DTO se consigue transferir datos entre capas sin exponer la estructura interna de las entidades JPA, evitando problemas como la serialización de relaciones \emph{lazy} y mejorando la seguridad al controlar qué información se envía al cliente. Los DTOs proporcionan flexibilidad en la representación de datos, permitiendo combinar información de múltiples entidades o mostrar vistas específicas según el contexto. Por ello, se facilita la evolución independiente de la API y el modelo de datos, donde se pueden modificar las entidades de la base de datos sin afectar los contratos de la API, y mejorando el rendimiento al reducir la cantidad de datos transferidos.
