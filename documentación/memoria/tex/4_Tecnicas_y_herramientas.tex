\capitulo{4}{Técnicas y herramientas}

\section{Metodologías}\label{metodologias}

\subsection{Scrum}\label{scrum}
Como marco de trabajo para la gestión del proyecto, se ha aplicado la metodología ágil Scrum. Scrum permite abordar el desarrollo de forma iterativa e incremental, facilitando la adaptación a los cambios y la mejora continua del producto. Mediante la planificación en \emph{sprints} de corta duración, se ha podido llevar a cabo la organización del trabajo de manera efectiva, asegurando que cada fase del proyecto se revisa y ajusta constantemente.

\section{Gestión del proyecto}\label{gestion-del-proyecto}

\subsection{Repositorio}\label{repositorio}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: \href{https://github.com/}{GitHub},
  \href{https://bitbucket.org/}{Bitbucket} y
  \href{https://gitlab.com/}{GitLab}.
\item
  Opción elegida: \href{https://github.com/}{GitHub}.
\end{itemize}

GitHub trabaja sobre un repositorio Git que lleva un control de versiones robusto y que permite documentar todo el proceso de desarrollo del proyecto académico, además ofrece la posibilidad de integración nativa con herramientas de CI/CD~\cite{ci-cd} facilitando la demostración de las buenas prácticas de desarrollo llevadas a cabo en el actual trabajo.
Además, GitHub ofrece la posibilidad de trabajar con \emph{issues} para organizar las diferentes tareas, pudiendo organizarlas por etiquetas o prioridades, así como la opción de \emph{taggear} las diferentes versiones o \emph{releases} que se alcanzan durante el desarrollo del proyecto.

\subsection{Control de versiones}\label{control-de-versiones}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: \href{https://git-scm.com/}{Git} y
  \href{https://subversion.apache.org/}{Subversion}.
\item
  Opción elegida: \href{https://git-scm.com/}{Git}.
\end{itemize}

Git es un sistema de control de versiones estándar en la industria que ha demostrado robustez y flexibilidad en todo tipo de desarrollos. Su capacidad de ramificación y fusión eficiente permite experimentar con diferentes funcionalidades sin afectar el código principal, y por su naturaleza distribuida garantiza múltiples respaldos del proyecto, permitiendo trabajar offline, aspecto muy útil para el desarrollo de cualquier tipo de proyecto.
Además, como cliente de Git, se ha utilizado TortoiseGit~\cite{tortoisegit} para todo lo referente a la documentación del proyecto.

\subsection{Integración continua y análisis de calidad}\label{integracion-continua-analisis-calidad}
GitHub Actions por su integración nativa con el repositorio permite automatizar el \emph{pipeline} de CI/CD directamente desde GitHub. Su facilidad de configuración mediante archivos YAML~\cite{yaml} permite habilitar la ejecución de diferentes \emph{workflows} para la compilación y empaquetado del proyecto, así como la comunicación con SonarCloud para el análisis estático del código para identificar bugs, vulnerabilidades y \emph{code smells} automáticamente. Su integración con GitHub Actions para análisis continuo en cada \emph{commit}, y el hecho de proporcionar métricas objetivas de calidad (cobertura de código, complejidad ciclomática, duplicación de código, etc...) enriquecen significativamente la documentación técnica del proyecto, ofreciendo un enfoque profesional de cara a la calidad del software.

\subsection{Documentación}\label{documentacion}
Para la documentación del proyecto se ha elegido \LaTeX{} desde la plataforma Overleaf~\cite{overleaf} por su capacidad de generar documentos académicos de una notable calidad con formatos consistentes y alta calidad tipográfica. La colaboración en tiempo real en la nube permite trabajar desde cualquier dispositivo y compartir fácilmente con los tutores para las revisiones. Por otro lado, la gestión automática de referencias bibliográficas y numeración elimina errores manuales y garantiza el cumplimiento de los estándares académicos.

\section{Patrones de diseño}\label{patron-de-diseño}

El sistema ha sido diseñado siguiendo principios de arquitectura en capas, separación de responsabilidades y buenas prácticas de desarrollo. A continuación, se describen algunos de los patrones utilizados.

\subsection{Patrón Modelo-Vista-Controlador (MVC)}\label{patron-modelo-vista-controlador}
Para la aplicación web de gestión de reservas con Spring Boot, se utilizó el patrón MVC por su separación clara de responsabilidades que facilita el mantenimiento y escalabilidad del código al dividir la lógica de negocio (Modelo), la presentación (Vista) y el control de flujo (Controlador). Su integración nativa con Spring Boot mediante las anotaciones que ofrece el \emph{framework} simplifica significativamente el desarrollo. Además, ofrece flexibilidad para cambios futuros como modificar la interfaz de usuario sin afectar la lógica de negocio, o modificar la lógica de negocio sin afectar a la capa visual o al modelo de datos.

\subsection{Arquitectura por Capas}\label{arquitectura-por-capas}
De alguna forma, o bien como consecuencia o bien como complementación al punto anterior, el patrón MVC favorece la construcción de los diferentes elementos separándose en diferentes capas, donde cada capa (presentación, lógica de negocio, acceso a datos) se alinea naturalmente con los componentes MVC, creando una estructura coherente y bien organizada. Esta combinación proporciona alta cohesión y bajo acoplamiento, permitiendo que los cambios en una capa (como modificar la base de datos) no afecten a las demás, mientras que MVC organiza la interacción usuario-sistema dentro de cada capa. Además, facilita la implementación de principios SOLID~\cite{solid} y permite el \emph{testing} independiente de cada capa, donde se puede probar la lógica de negocio sin depender de la interfaz de usuario o la base de datos. Esta sinergia entre arquitectura por capas y MVC es una buena práctica que conduce a un diseño maduro y profesional que cumple con los estándares de la industria para el desarrollo de aplicaciones.

\subsection{Patrón Repository}\label{patron-repository}
Al disponer Spring Boot de una integración nativa con Spring Data JPA, se permite la creación de repositorios automáticamente mediante interfaces, reduciendo significativamente el código. Este patrón abstrae la lógica de acceso a los datos de la capa de negocio, permitiendo cambiar la implementación de persistencia sin afectar el resto de la aplicación y facilitando el \emph{testing} mediante \emph{mocks}. Además, Spring Boot proporciona funcionalidades avanzadas como \emph{query methods} automáticos y paginación, mientras que el uso de este patrón garantiza el cumplimiento del principio de inversión de dependencias, creando una arquitectura limpia y mantenible.
\imagen{patron-repository2}{Patrón Repository.}{1}

\subsection{Patrón Service Layer}\label{patron-service-layer}
Gracias a la utilización del patrón de diseño MVC comentado anteriormente, conduce casi de forma intuitiva o directa al uso del patrón \emph{service layer} actuando como intermediario entre los \emph{Controllers} y los \emph{Repositories}, encapsulando toda la lógica de negocio y las reglas de validación en una capa dedicada que mantiene los controladores ligeros y enfocados únicamente al manejo de peticiones HTTP. Su integración con Spring Boot mediante \emph{@Service} facilita la inyección de dependencias y la gestión transaccional con \emph{@Transactional}, mientras que permite reutilizar la lógica de negocio desde diferentes controladores o incluso APIs REST y servicios web. Este patrón refuerza la separación de responsabilidades del MVC, donde el Controller delega las operaciones complejas al Service, que a su vez utiliza los \emph{Repositories} para la persistencia, creando una arquitectura limpia, testeable y que cumple con los principios de buenas prácticas del diseño de software.

\subsection{Patrón Data Transfer Object (DTO)}\label{patron-data-transfer-object}
Con el uso del patrón DTO se consigue transferir datos entre capas sin exponer la estructura interna de las entidades JPA, evitando problemas como la serialización de relaciones \emph{lazy} y mejorando la seguridad al controlar qué información se envía al cliente. Los DTOs proporcionan flexibilidad en la representación de datos, permitiendo combinar información de múltiples entidades o mostrar vistas específicas según el contexto. Además, facilitan la evolución independiente de la API y el modelo de datos, donde se pueden modificar las entidades de base de datos sin afectar los contratos de la API, y mejoran el rendimiento al reducir la cantidad de datos transferidos.

\section{Librerías}\label{librerias}

\subsection{JUnit}\label{junit}
JUnit es considerado el \emph{framework} de \emph{testing} estándar de facto en Java que viene integrado nativamente con Spring Boot Test, facilitando la escritura de tests unitarios y de integración sin tener que realizar una configuración adicional. Su sintaxis intuitiva con anotaciones permite crear tests legibles y mantenibles, posibilitando el testing de controladores y servicios de forma aislada. Además, JUnit proporciona reporting detallado de resultados y se integra perfectamente con herramientas de CI/CD como GitHub Actions y análisis de cobertura con SonarCloud, permitiendo obtener métricas de cobertura de la calidad del software.

\subsection{Mockito}\label{mockito}
Para complementar los \emph{tests} unitarios implementados con JUnit, se ha utilizado la librería Mockito por su capacidad de crear \emph{mocks} y \emph{stubs} de dependencias que permiten aislar completamente los elementos bajo prueba, resultando especialmente útil para testear servicios sin depender de \emph{repositories} reales o bases de datos. Su integración con JUnit mediante anotaciones como \emph{@Mock} y \emph{@InjectMocks} simplifica la configuración de tests, mientras que su sintaxis intuitiva con métodos como \emph{when().thenReturn()} hace que los \emph{tests} sean legibles y entendibles. Con el uso de Mockito se ha posibilitado el testing de la capa de servicios en la arquitectura por capas, permitiendo verificar interacciones entre componentes (\emph{verify()}) y simular diferentes escenarios de error o éxito sin la complejidad de configurar un entorno completo, lo que resulta práctico para demostrar buenas prácticas de testing en un proyecto.

\newpage

\section{Desarrollo Web}\label{desarrollo-web}

\subsection{Thymeleaf}\label{thymeleaf}
Por su integración nativa y oficial con Spring Boot, se ha utilizado Thymeleaf ya que elimina configuraciones adicionales y proporciona soporte completo para el patrón MVC mediante resolución automática de plantillas y \emph{binding} de modelos. Su sintaxis natural en HTML permite que las plantillas sean visualizables en navegadores sin procesamiento, facilitando el desarrollo colaborativo con diseñadores, mientras que sus expresiones Spring EL se integran perfectamente con los objetos del modelo pasados desde los controladores. Además, Thymeleaf ofrece características específicas para aplicaciones web como validación de formularios integrada con Spring Validation, internacionalización automática, y fragmentos reutilizables, creando una solución completa que demuestra un uso adecuado del ecosistema Spring para el desarrollo de aplicaciones web.

\subsection{Bootstrap}\label{bootstrap}
Como complementación de Thymeleaf, se ha utilizado Bootstrap por su integración sencilla con sus plantillas o los recursos estáticos de Spring Boot, permitiendo aplicar clases CSS directamente en los elementos HTML, así como crear interfaces responsivas sin una configuración compleja. Su sistema de componentes predefinidos (formularios, tablas, modales) se adapta perfectamente a las funcionalidades utilizadas en la aplicación, mientras que la gestión de recursos estáticos de Spring Boot permite servir Bootstrap de forma optimizada y cacheable. Además, Bootstrap proporciona consistencia visual y experiencia de usuario sin requerir conocimientos avanzados de CSS, permitiendo que el proyecto se enfoque en la lógica de negocio y la arquitectura del \emph{backend} manteniendo una interfaz moderna y funcional.

\subsection{JavaScript}\label{javascript}
Se ha utilizado JavaScript por su capacidad para añadir interactividad dinámica para aquellos cometidos en los que Bootstrap no puede proporcionar por sí solo, como validación de formularios en tiempo real, calendarios interactivos para selección de fechas de reserva, y componentes dinámicos que mejoren la experiencia de usuario sin recargar la página. Su integración natural con Thymeleaf permite generar código JavaScript dinámico con datos del servidor, mientras que se complementa perfectamente con los componentes de Bootstrap añadiendo funcionalidad a modales, \emph{dropdowns}, y formularios mediante \emph{event listeners} y manipulación del DOM\footnote{DOM es la sigla de document object model}. Además, JavaScript permite comunicación asíncrona con el \emph{backend} mediante AJAX~\cite{ajax} para funcionalidades como verificación de disponibilidad de reservas en tiempo real, creando una aplicación web moderna e interactiva.

\subsection{CSS}\label{css}
Se ha decidido el uso de un CSS personalizado por su capacidad de adaptación y extensión de los estilos de Bootstrap sin modificar el \emph{framework} base, permitiendo crear una identidad visual propia para la aplicación mediante variables CSS personalizadas y una sobreescritura selectiva de clases Bootstrap. Su integración con Thymeleaf permite aplicar estilos condicionales y crear hojas de estilo específicas para diferentes vistas de la aplicación de reservas. Además, CSS permite optimizar la experiencia de usuario con animaciones o transiciones que complementen la \emph{responsividad} de Bootstrap, mientras que facilita la personalización específica de elementos visuales que Bootstrap no cubre.

\section{Entorno de desarrollo integrado (IDE)}\label{entorno-de-desarrollo-integrado}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: 
  \href{https://code.visualstudio.com/}{Visual Studio code}, 
  \href{https://eclipse.org/}{Eclipse} y
  \href{https://www.jetbrains.com/idea/}{IntelliJ IDEA}.
\item
  Opción elegida: \href{https://eclipse.org/}{Eclipse}.
\end{itemize}

Para la codificación de la aplicación, se ha utilizado Eclipse como IDE de desarrollo por su integración nativa con el ecosistema Java empresarial y su excelente soporte para proyectos Maven/Gradle, \emph{debugging} avanzado, y herramientas específicas de Spring como Spring Tool Suite (STS) que facilitan el desarrollo con autocompletado inteligente y configuración automática. Su gestión robusta de proyectos grandes con refactoring automático, navegación de código eficiente, e integración con sistemas de control de versiones como Git lo hacen adecuado para la organización y mantenibilidad del código a largo plazo. Además, Eclipse ofrece plugins especializados para tecnologías del proyecto como Thymeleaf, JUnit, asistentes a la codificación como GitHub Copilot~\cite{github-copilot} y herramientas de análisis de código, mientras que por su naturaleza gratuita y \emph{open-source} lo convierten en una opción accesible para cualquier desarrollador para su uso como herramienta profesionales estándar de la industria Java sin costos adicionales.
