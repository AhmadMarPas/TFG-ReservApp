\capitulo{5}{Aspectos relevantes del desarrollo del proyecto}

\section{Ciclo de vida y metodología de desarrollo}\label{ciclo-de-vida-metodologia-desarrollo}
Para el desarrollo de la aplicación de gestión de reservas, se adoptó un ciclo de vida iterativo-incremental basado en la metodología ágil Scrum, estructurado en \emph{sprints} de una semana que permitió una evolución controlada y adaptativa del producto. Aunque el uso de scrum no ha sido del rigurosamente estricto a todas las directrices establecidas por el marco de trabajo, principalmente debido a que no se trataba de un equipo de desarrollo al uso, sí que se ha aplicado la filosofía que promueve Scrum como es el desarrollo incremental, revisiones de hitos alcanzados, adaptación al cambio, planificación de los siguientes sprints, etc... Esta decisión se justificó por la naturaleza académica del proyecto, donde los requisitos iniciales podían evolucionar conforme se avanzaba en el desarrollo de la aplicación y se identificaban nuevas necesidades o modificaciones durante las reuniones con los tutores.\\
La gestión de riesgos técnicos se planificó desde el primer sprint, identificando como principales amenazas los conflictos de dependencias entre Spring Boot y otras librerías como las librerías de testing, así como posibles problemas de rendimiento en consultas concurrentes de disponibilidad de salas. Para mitigar estos riesgos, se estableció un entorno de desarrollo con perfiles específicos (desarrollo, testing, producción).\\
Para la evolución de requisitos inicialmente se planificó un sistema básico de reservas, pero durante el desarrollo se identificó la necesidad de implementar funcionalidades como notificaciones por correo, el registro de auditoría para identificar quién creaba o modificaba la información y cuándo se producía. 
Una decisión importante que surgió durante el desarrollo fue la implementación de borrado lógico en lugar de eliminación física de registros, lo que implicó rediseñar el modelo de datos para incluir el campo válido y modificar todas las consultas JPA para filtrar registros válidos. Esta decisión, aunque incrementó la complejidad inicial, proporcionó trazabilidad completa de las operaciones y capacidad de recuperación de datos.\\
Otro cambio arquitectónico relevante fue la flexibilización del sistema de duración de reservas, evolucionando desde un modelo rígido, de duración libre, hacia la posibilidad de establecer slots predefinidos consiguiendo un sistema híbrido que soporta tanto duraciones libres como intervalos configurables por sala. Esta funcionalidad requirió implementar una lógica compleja de validación de solapamientos que considerara ambos escenarios, desarrollando soluciones específicas para detectar conflictos entre reservas de duración libre y aquellas que siguen slots horarios. El diseño modular por capas y el uso de patrones como Service Layer permitieron incorporar estos cambios sin afectar significativamente la arquitectura base, demostrando la flexibilidad de la metodología ágil para adaptarse a requisitos emergentes en proyectos como el actual.\\

\section{Decisiones arquitectónicas}\label{decisiones-arquitectonicas}
Una de las decisiones más significativas durante las primeras fases del proyecto fue la elección de la tecnología para la capa de presentación. Inicialmente se contempló utilizar JSF (JavaServer Faces)~\cite{jsf} con PrimeFaces~\cite{primefaces} como \emph{framework} de interfaz de usuario, motivado principalmente por la experiencia en ello y por su rico conjunto de componentes predefinidos y su capacidad para crear interfaces web complejas con mínimo código JavaScript. PrimeFaces ofrece componentes avanzados como calendarios interactivos, tablas con filtrado automático y diálogos modales que parecían ideales para las funcionalidades de gestión de reservas.
Sin embargo, tras una evaluación técnica e investigación sobre diferentes opciones para la capa de presentación, se decidió migrar hacia Thymeleaf por los siguientes factores:
\begin{itemize}
\tightlist
\item
La integración nativa con Spring Boot eliminaba configuraciones complejas de JSF y proporcionaba soporte automático para el patrón MVC mediante resolución de plantillas y \emph{binding} de modelos.
\item
Aunque no se tenía experiencia previa con ninguna de las dos tecnologías, Thymeleaf presentó una curva de aprendizaje más suave al trabajar directamente con HTML válido, permitiendo que las plantillas fueran visualizables en navegadores sin procesamiento del servidor, lo cual facilitaba el desarrollo y debug.
\end{itemize}
La decisión final se basó en que Thymeleaf se alineaba mejor con los objetivos académicos del TFG al demostrar un uso profesional del ecosistema Spring, mientras que JSF habría requerido configuraciones adicionales y conocimiento específico de ciclos de vida de componentes que podrían haber desviado el foco del aprendizaje hacia aspectos menos relevantes para el dominio del problema. Esta elección resultó acertada, permitiendo concentrar los esfuerzos en la lógica de negocio y la arquitectura del sistema de reservas.\\

\section{Aspectos técnicos específicos del stack}\label{aspectos-terncicos-del-stack}
Una de las implementaciones técnicas más relevantes del proyecto fue la configuración de \emph{workflows} automatizados de CI/CD que garantizaran la calidad del código y la entrega continua de la aplicación. Se desarrollaron dos \emph{workflows} principales en GitHub Actions que se ejecutan automáticamente en cada \emph{push} y \emph{pull request} al repositorio.\\
El primer \emph{workflow} de compilación y empaquetado se configuró para ejecutarse en múltiples versiones de Java, garantizando la compatibilidad multiplataforma. Este \emph{workflow} incluye la descarga automática de dependencias Maven, la compilación del código fuente, la generación del archivo WAR~\cite{war} desplegable y su posterior almacenamiento como artefacto de GitHub. La configuración incluye optimizaciones como el \emph{caching} de dependencias Maven para reducir los tiempos de \emph{build} y la paralelización de tareas donde fue posible.\\
El segundo \emph{workflow} de \emph{testing} y análisis de calidad representa la implementación más compleja, ya que requirió la configuración de un servicio MySQL dedicado para las pruebas de acceso a datos. Esta decisión técnica implicó parametrizar una instancia de MySQL como servicio de GitHub Actions con variables de entorno específicas, así como configurar los \emph{health checks} correspondientes para garantizar que la base de datos estuviera completamente operativa antes de ejecutar los \emph{tests} de integración. La configuración incluyó la creación de un perfil específico de Spring Boot (test) con propiedades de conexión que apuntaran al servicio MySQL del workflow, diferenciándolo del perfil de desarrollo que utiliza H2 en memoria.\\
El \emph{workflow} orquesta la ejecución secuencial de \emph{tests} unitarios (que no requieren base de datos) y \emph{tests} de integración (que utilizan la instancia MySQL), la generación de reportes de cobertura unificados con JaCoCo~\cite{jacoco}, y la transmisión de métricas hacia SonarCloud para el análisis estático. La configuración requirió la gestión de \emph{secrets} de GitHub para las claves de autenticación de SonarCloud, así como la configuración específica de paths de exclusión para evitar el análisis de código generado automáticamente
\imagen{workflow}{Secuencia con las distintas tareas del Workflow.}{1}

Un desafío técnico significativo fue sincronizar los reportes de cobertura de JaCoCo con los requisitos de SonarCloud, lo que implicó configurar correctamente los paths relativos en el archivo ''sonar-project.properties'' y asegurar que los reportes XML se generaran en las ubicaciones exactas esperadas por SonarCloud. Esta configuración permite obtener métricas objetivas de calidad como cobertura de código, complejidad ciclomática, duplicación de código y detección automática de \emph{code smells}, proporcionando retroalimentación continua sobre la salud técnica del proyecto.
